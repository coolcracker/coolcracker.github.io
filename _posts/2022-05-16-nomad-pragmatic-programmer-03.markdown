---
title:  "Pragmatic Programmer Challenge 03"
date:   2022-05-16 01:04:23
categories: [Pragmatic Programmer]
tags: [Pragmatic Programmer]
---
### 오늘 TIL 3줄 요약

- 나쁜 코드야말로 많은 주석을 필요로 한다. DRY 원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두라고 말한다. 그렇지 않으면 지식을 중복하게 되며, 변경할 때마다 매번 코드와 주석을 모두 바꾸어야 한다. 주석은 필연적으로 낡게 될 것이고, 믿을 수 없는 주석은 전혀 없는 것보다 더 심각한 문제를 만들어 낸다.
- 직교적으로 살아가기 : DRY 원리로 무장하고 직교성 원리를 충실히 사용한다면 개발하고 있는 시스템이 더 유연하고, 이해하기 쉽고 또한 디버그, 테스트, 유지도 쉬워질 것이다. → 직교적이지 않은 시스템은 리팩토링을 할 시간이다.
- 예광탄 코드가 프로토타이핑과 다른 점은 프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 진짜 프로토타입 방식을 따른다면, 어떤 개념을 구현해 보려고 시도할 때 대충끼워 맞춘 것들을 모두 버린 다음, 실험 과정에서 얻은 교휸을 바탕으로 다시 코드를 만들게 된다.

### TIL (Today I Learned)  날짜

- 22년 05월 15일~22년 05월 16일

### 오늘 읽은 범위

- 2장. 실용주의 접근법

### 책에서 기억하고 싶은 내용을 써보세요.

p.63

- 소프트웨어 개발의 모든 차원에 적용가능한 팁과 요령이 있고, 거의 공리와 같은 아이디어들이나 사실상 보편화된 프로세스들이 있다. 하지만 이런 접근법들은 문서로 만들어진 경우가 드물다. 주로 설계나 프로젝트 관리, 코딩 등의 논의 중에 간혹 몇 문장 적혀있는 것을 볼 수 있을 것이다. 이 장에서는 이런 아이디어들과 프로세스들을 한데 모아 보려고 한다.
- 나오는 것들
    - 중복의 해악 : 시스템을 통틀어 어떤 지식을 중복하지 말라고 경고
    - 직교성(Orthogonality) : 하나의 지식을 여러 개의 시스템 컴포넌트에 쪼개 놓지 말라고 조언
    - 가역성(Reversibility) : 변화하는 환경(변화의 속도가 빨라짐에 따라, 애플리케이션을 적절하게 유지하는 것을 점점 더 어려워진다.)에서 프로젝트를 분리하는 몇 가지 기법
    - 예광탄(Tracer Bullets) : 요구사항을 모으고, 설계를 테스트하고, 코드를 구현하는 것을 도시에 가능케 하는 개발 스타일
        - 항상 적용 가능한 것은 아니다. 그렇지 못할 때에는 “프로토타입과 포스트잇"에서 아키텍처, 알고리즘, 인터페이스, 아이디어 등을 테스트하기 위해 프로토타입을 어떻게 사용할지 보게 될 것이다.
    - 도메인 언어(Domain Language) : 스스로 구현할 수 있는 좀 더  현실적인 제안
    - 추정(Estimating) : 어떤 일들이 얼마나 걸릴지 아는데 능숙해지면 시간과 자원이 제한된 세상에서 일할 때 이런 희소성을 더 잘 극복할 수 있다.

p.65

- 중복의 해악
    - 프로그래머로서 우리는 지식을 수집하고, 조직하고, 유지하며, 통제한다. 우리는 명세서에 지식을 문서화하고 실행 코드에서 그 지식이 생명을 갖고 살아나도록 한다. 그리고 그 지식에서 테스트 중에 점검할 사항들을 제공받는다.
    - 불행히도 지식은 고정적이지 않다. 그것은 변화한다.
        - 클라이언트와의 미팅 직후
        - 정부의 규제 변경
        - 어떤 비즈니스 로직은 더 이상 맞지 않음
        - 테스트는 선택된 알고리즘이 제대로 동작하지 않을 것이라고 보여줌
        - 이러한 모든 불안정성은 우리가 소위 유지보스 모드에서 시스템에 대한 지식을 재조직하고 재표현하는 데 대부분의 시간을 보내게 되라라는 것을 의미한다.
    - 프로그래머들은 늘 유지보수 모드에 있다. 우리가 이해하고 있는 것은 날마다 바뀐다. 설계를 하거나 코딩을 하는 중에 새로운 요구사항이 도착한다. 어쩌면 환경이 변할 수도 있다. 이유가 무엇이건 간에, 유지보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.

p.66

- 위와 같이 유지보수를 하다보면 명세와 프로세스 그리고 프로그램을 개발하는 중에 지식을 중복해서 넣기 쉽다는 것이다. → 유지보수의 악몽이 시작된다.
- 소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 우리가 DRY 원칙이라고 부르는 것을 따르는 것뿐이라 생각한다.
- DRY(Don’t Repeat Yourself) : 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야 한다.
    - DRY를 따르지 않는다면 똑같은 것이 두 군데 이상에 표현되어있을 것이고 만약 하나를 바꾼다면 나머지 것들도 바꿔야 한다.
    - 실용주의 프로그래머의 도구 상자에서 가장 중요한 도구 중 하나라고 생각한다.

p.67

- 어떻게 중복이 생기는가?
    - 강요된(impose) 중복 : 개발자들은 다른 선택이 없다고 느낀다. 환경이 중복을 요구하는 것처럼 보인다.
    - 부주의한 중복 : 개발자들은 자신들이 정보를 중복하고 있다는 것을 깨닫지 못한다.
    - 참을성 없는 중복 : 중복이 쉬워 보이기 때문에 개발자들이 게을러져서 중복을 하게 된다.
    - 개발자간의 중복 : 한 팀에 있는(혹은 다른 팀에 있는) 여러 사람들이 동일한 정보를 중복한다.
- 강요된 중복
    - 프로젝트 표준이 중복된 정보가 기록된 문서를 요구
    - 코드에 중복 정보가 생기는 문서를 요구
    - 여러 플랫폼 지원
    - 프로그래밍 언어 자체가 정보가 중복되는 어떤 구조를 요구

p68

- 강요된 중복
    - 정보의 다양한 표현 양식 : 동일한 정보가 다른 형태로 표현해야하는 경우(클라이언트와 서버 간 다른 언어를 사용하지만 공통된 구조를 양쪽에서 표현하는 경우) 간단한 필터나 코드 생성기(p.179)를 작성하는 것이 해답
    - 코드내의 문서화 : 나쁜 코드야말로 많은 주석을 필요로 한다. DRY 원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두라고 말한다. 그렇지 않으면 지식을 중복하게 되며, 변경할 때마다 매번 코드와 주석을 모두 바꾸어야 한다. 주석은 필연적으로 낡게 될 것이고, 믿을 수 없는 주석은 전혀 없는 것보다 더 심각한 문제를 만들어 낸다.(p.385)
    - 문서화와 코드 : 여러분은 문서를 작성하고 코드를 작성한다. 뭔가가 바뀌면 문서를 수정하고 코드를 갱신한다. 모두 동일 지식에 대한 표현이다. 마감일이 다가오는 긴박한 시기가 되면 문서 갱신을 뒤로 미루기 쉽다.

p.69

- 언어에 관한 문제
    - 많은 언어가 소스코드에 상당한 양의 중복을 강요한다. 이것은 언어가 모듈의 인터페이스와 그 구현을 분리하는 경우에 자주 생긴다. (C, C++, Pascal)

p.70

- 부주의한 중복
    - 때때로 중복은 설계 실수의 결과로 나타나기도 한다.
        - 2개의 각 class 설계에서 중복된 속성을 가진 경우 변경이 두 곳에서 일어나야 하므로 중복이 발생된다.
        - 1개의 class 설계에서 다른 두 속성으로 유추 가능한 다른 속성이 있는 경우 중복이다.
    - 가능한 곳에서는 언제나 객체의 속성을 읽고 쓸 수 있는 액세스 함수를 사용하라.

p.73

- 참을성 없는 중복
    - 모든 프로젝트는 시간의 압박을 받는다. 유사 코드를 복사 붙여넣기 하는 유혹을 느낀다면 “돌아가는 길이 지름길이다"라는 진부한 격언을 기억하라. 지금 당장 몇 초를 절약할 수 있을지라도, 나중에는 몇 시간을 잃게 될런지 모른다. → 나중의 고통을 피하기 위해서는 훈련이 필요하고, 미연에 시간을 투자할 의지가 있어야 한다.
- 개발자간의 중복
    - 발견하거나 다루기 가장 어려운 유형의 중복은 한 프로젝트에서 일하는 서로 다른 개발자 사이에서 발생한다.
    - 높은 차원의 해법으로, 깨끗한 설계와 강력하고 기술적인 프로젝트 리더(p.358), 그리고 그 설계 내에서 책임의 분배가 제대로 이해되도록 하는 것, 이런 것들로 개발자 간의 중복 문제를 다루어라.
    - 최선책은 개발자간에 적극적이고 빈번한 소통을 장려하는 것이다. 공통의 문제를 다루기 위한 토론장을 만들어라.
        - 닫힌 뉴스넷 활용
        - 팀원 중 한명을 사서로 임명
        - 유틸리티 루틴과 스크립트들이 저장될 수 있는 장소 마련
        - 의례히 비공식적으로 혹은 코드 리뷰시 다른 사람의 소스코드와 문서를 읽도록 하라.
        - 따라서 여러분이 조성해야할 환경이란 뭔가를 직접 만드는 것보다 기존의 것을 찾아내고, 또 재사용하기 쉬운 환경이다. → 재사용에 실패한다면 지식 중복의 위험을 각오해야한다.

p.76

- 직교성
    - 설계, 빌드,테스트 그리고 확장하기에 쉬운 시스템을 만드는 데에 있어 직교성은 매우 중요한 개념이다.
    - 기하학에서 빌려온 용어로 직교할 경우 하나가 바뀌어도 나머지에 어떤 영향도 주지 않는다.

p.77

- 비직교적인 시스템
    - 특정 하나를 조작하면 그에 따른 파생 효과를 일으키는 시스템을 날리고 있는 중이라는 것을 깨닫게 된다. 변화의 각각이 다시 다른 모든 조정 해위에 영향을 끼친다.
- 직교성의 장점
    - 비직교적인 시스템은 본질적으로 변화와 조정을 하기가 복잡하다. 시스템의 컴포넌트들이 고도로 상호의존적인 경우, 특정 국지적 부분만 수정하는 방법이란 없다.
    - 관련 없는 것들 간에 서로 영향이 없도록 하라.
    - 우리는 자족적인 컴포넌트를 설계하기 원한다. 독립적이며, 단일하고 잘 정의된 목적을 가진 컴포넌트. 컴포넌트들이 각기 격리되어 있으면 어느 하나를 바꿀 때 나머지 것들을 걱정하지 않아도 된다.
    - 큰 장점 두가지
        - 생산성 향상
            - 변화가 국소화되서 개발시간과 테스트 시간이 줄어든다.
            - 재사용을 촉진한다. 시스템이 더 느슨하게 결합되어 있을수록 재설정하고 리엔지니어링하기 쉽다.
            - 직교적인 컴포넌트를 결합할 때 꽤 미묘한 생산성 향상이 있다.  M 가지 일을 하는 컴포넌트와 N 가지 일을 하는 컴포넌트를 결합하면 M x N 개의 일을 한다. 직교적이지 못하면 겹치는 부분이 있고 결과물이 할 수 있는 일은 그 이하일 것이다.
        - 리스크 감소
            - 감염된 코드는 격리된다.
            - 시스템이 잘 깨어지지 않는다.
            - 테스트를 설계하고 실행하기 쉽기 때문에 더 많은 테스트를 하게 된다.
            - 써드파티 컴포넌트로 연결되는 인터페이스들이 전체 개발의 작은 부분에 한정되기 때문에 특정 벤더나 제품, 플랫폼에 덜 종속될 것이다.

p.79

- 프로젝트 팀
    - 어떤 팀은 구성원들이 끊임없이 말다툼하고 서로 방해가 되는 반면, 어떤 프로젝트 팀은 얼마나 효율적인지, 모든 구성원들이 무엇을 할지 잘 알고 있으며, 또 전적으로 기여하고 있는지는 종종 직교성의 문제이다.
    - 팀 내 업무가 겹치는 영역이 많다면 구성원들은 책임 영역에 대해 혼동하게 되고 하나를 변경하고자 하면 전체 팀원이 모여야 한다.
    - 어렵지만 팀을 잘 조직해서 책임이 잘 정의되어 있고 중복이 최소화된 그룹으로 만들어야 한다.
    - 프로젝트 팀 구조가 얼마나 직교성을 갖는지 간단히 측정해 볼 수 있는 방법이 있다. 요청된 개별 변화에 대한 토론에 참여할 필요가 있는 사람이 몇 명인가를 보라. 숫자가 클수록 그룹의 직교성은 낮다. 직교적인 팀이 더 효율적임이 명백하다. (이렇게 말을 하면서도, 이와 동시에 서브팀들끼리 지속적으로 의사소통할 것을 장려한다.)

p.80

- 설계
    - 개발자 대다수는 직교적인 시스템을 설계할 필요를 잘 안다.
    - 시스템은 협력하는 모듈의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 때로는 이런 컴포넌트들이 레이어로 조직되기도 하는데, 각 레이어는 하나의 추상화 층을 이루게 된다. 이 레이어식 접근은 직교적 시스템을 설계하는 강력한 방법이다. 각 레이어는 자기 밑에 있는 레이어들이 제공하는 추상화만을 사용하기 때문에, 코드에 영향을 끼치지 않으면서 아래에 있는 다른 구현들을 바꾸는 높은 유연성을 얻을 수 있다. 레이어를 두는 것은 또한 모듈 간에 종속성이 빨리 늘어나는 위험을 감소시킨다.
    - 직교적인 설계를 테스트하는 손쉬운 방법이 있다. 컴포넌트들을 나누었을 때 다음과 같이 스스로에게 물어봐라. “특정 기능에 대한 요구사항을 극적으로 변경했을 경우, 몇 개의 모듈이 영향을 받는가?” 직교적인 시스템에서는 답이 “하나"여야 한다.
    - p253에서 MVC(모델-뷰-컨트롤러) 패러다임을 잉요해 코드간의 결합도를 줄이는 방법에 대해 설명한다.

p.82

- 툴킷과 라이브러리 : 써드파티 툴킷이나 라이브러리를 도입할 때, 시스템의 직교성을 보존할 수 있는지 주의 깊게 살펴보기 바란다. 기술을 현명하게 선택하라.
    - 엔터프라이즈 자바빈즈 시스템은 직교성에 대한 흥미로운 예제이다. 애플리케이션 코드가 메타데이터를 이용해 표현하기 때문에 코드밖에 존재한다. 그러므로 같은 애플리케이션 코드가 서로 다른 EJB 트랜잭션 환경에서도 변경 없이 실행될 수 있다.
    - AOP(Aspect-Oriented Programming)은 로깅과 같은 공통 기능은 여러 클래스에 퍼져 있기 쉽다는 단점에 착안하여 이와 같은 횡단적 관심사(crosscutting concerns)를 한 곳에서 처리할 수 있도록 도와준다. 소스코드 이곳저곳에 분산되어 있을 코드를 한 곳에 모아준다. 유명한 자바용 AOP 툴로는 AspectJ와 Hibernate AOP가 있다.

p.84

- 직교성 유지를 위한 코딩 기법
    - 코드의 결합도를 줄여라 : 부끄럼타는 코드(shy code)를 작성하라. 즉 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라. p227쪽에서 논의하는 디미터 법칙을 따르려 노력해보자. 객체의 상태를 바꿀 필요가 있다면, 객체 스스로가 여러분을 위해 그러한 일을 수행하게 만들라.
    - 전역 데이터를 피하라 : 코드가 전역 데이터를 참조할 때마다, 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다. 디자인 패턴에서 소개하는 싱글튼 패턴은 특정 클래스의 객체가 단 하나의 인스턴스만을 갖도록 보장해준다. (하지만 많은 개발자들이 싱글튼 객체를 전역 데이터의 일종으로 남용한다. 특히 자바와 같이 전역 개념을 지원하지 않는 언어의 경우에는 더욱 심하다. 싱글튼을 사용할 때는 주의를 기울여라.)
    - 유사한 함수를 피하라 : 중복 코드는 구조적 문제의 징후이다. “디자인 패턴"에서 소개한 스트래티지 패턴(Strategy pattern)을 사용하여 더 나은 구현을 할 수는 없는지 고려해보기 바란다.
    - 자신이 작성하는 코드를 항상 비판적으로 검토해 보는 습관을 기르기 바란다. 기회가 있을 때마다 코드의 구조와 직교성을 향상시키기 위해 노력하라. → 이러한 프로세스를 리팩토링이라 부르며 너무 중요하기 때문에 별도의 항목을 p291에 할당했다.

p.86

- 테스트 : 직교적으로 설계, 구현한 시스템은 모듈 수준의 테스트를 하기 더 쉽다. 모든 모듈이 자신만의 단위 테스트를 위한 테스트케이스를 갖고, 테스트가 정규 빌드 과정의 일부로 수행되어야 한다고 생각한다.

p.87

- 문서화 : 직교성은 놀랍게도 문서에도 적용할 수 있다. 내용과 표현이 두축이 된다. 정말 직교적인 문서라면 내용 변화 없이 표현을 극적으로 바꿀 수 있을 것이다. p.385 참고.
- 직교적으로 살아가기 : DRY 원리로 무장하고 직교성 원리를 충실히 사용한다면 개발하고 있는 시스템이 더 유연하고, 이해하기 쉽고 또한 디버그, 테스트, 유지도 쉬워질 것이다. → 직교적이지 않은 시스템은 리팩토링을 할 시간이다.

p.90

- 가역성
    - 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다.
    - 영원한 것은 없다. 만약 여러분이 어떤 사실을 굳게 믿고 그 사실에 전적으로 의존하고 있다면, 거의 100% 그것이 변하게 될 거라고 이야기 해주고 싶다.
    - 이것은 이 방법으로만 해결할 수 있어와 같은 근시안적인 생각을 갖고 프로젝트에 참여한다면 아마도 예상치 못했던 경우에 의해 한숨지을 일이 많을 것이다.
    - 이 책의 많은 주제들은 유연하고, 적응 가능한 소프트웨어를 만드는 방법에 대해 설명한다. 이러한 추천안들, 특히 DRY 원리(p66), 결합도 줄이기(p227), 메타데이터 상요하기(p235)를 따른다면 중요하면서도 되돌릴 수 없는 결정을 가능한 줄일 수 있게 될 것이다.
    - 결정이 돌이 새겨지는 것이라 가정하고, 발생할지도 모를 우연한 사건들에 대해 준비하지 않은 데에서 실수가 나온다. 결정이 돌에 새겨진 것이 아닌라 해변가의 모래 위에 쓰인 글씨라 생각해보자. 언제든지 큰 파도가 글씨를 지워버릴 수 있다.
    - 최종 결정이란 없다.

p.93

- 유연한 아키텍처 : 많은 사람들이 코드를 유연하게 유지하려고 노력한다. 하지만 아키텍처, 배포, 벤더 통합 영역의 유연성에 대해서도 관심을 기울일 필요가 있다.
- 적절히 캡슐화가 되어 있지 않고, 결합도가 높으며, 하드코딩된 로직과 매개 변수가 많다면 거의 불가능할 것이다.
- 지금까지 어떤 하나만을, 즉 어떤 하나의 제한된 결정만을 수행하는 프로그램을 작성하지 않았는가?
- 누구도 미래에 대해서는 알 수 없으며, 우리라고 예외는 아니다. 여러분의 코드가 로큰롤을 할 수 있게 하라. 락을 할 수도 있고 필요한 경우 롤을 할 수도 있게 하는 것이다.
- 슈뢰딩거의 고양이를 생각하면서 여러분의 코드는 몇 가지 가능한 미래를 지원할 수 있는가? 어떤 미래가 일어날 가능성이 높을까? 그 미래가 닥쳤을 때, 이를 지원하는 것이 얼마나 어려울까? 상자를 열 용기가 있는가?

p.96

- 예광탄 : 탄창의 일반 탄환들 사이에 일정한 간격으로 끼어있다. 발사되면 그 안에 든 인 성분이 발화하여 총알을 맞은 것과 총 사이에 빛의 궤적을 남긴다.
    - 기관총 사수와 마찬가지로 여러분도 어둠 속에서 목표물을 맞추어야 한다. 사용자들이 이전에 그럴ㄴ 시스템을 한 번도 본 적이 없기 때문에 요구사항이 막연할지도 모른다.
    - 익숙하지 않은 알고리즘, 기술, 언어, 라이브러리들을 사용해야 할지도 모르므로, 여러분은 수많은 미지의 것과 맞닥뜨리게 된다. 그리고 프로젝트는 완성하는 데 시간이 걸리기 때문에, 일을 마치기 전에 여러부의 작업을 둘러싼 환경이 변화하리라는 것도 거의 확실히 장담할 수 있다.
    - 시스템이 돌아갈 때까지 세세히 명세화하는 것이 이런 상황에서의 전형적인 반응이다.
    - 하지만 실용주의 프로그래머는 예광탄 사용을 선호한다.

p.97

- 어둠 속에서 빛을 내는 코드
    - 코딩에서도 예광탄과 동일한 효과를 얻으려면, 우리를 요구사항으로부터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달하게 해줄 무엇가를 찾아야 한다.
    - 예광탄 코드는 나중에 버리려고 만드는 것이 아니다. 그것은 계속 사용할 코드다. 상용 코드와 마찬가지로 모든 에러 검사, 구조화 , 문서화, 자기 검사가 포함된다.
    - 예광탄 개발 방법은 프로젝트는 결코 끝나지 않는다는 관념과도 일맥상통한다. 변화에 대한 요구와 추가할 기능은 언제나 계속 생기기 마련이다. 예광탄 개발 방법은 점진적인 접근 방법이다. (이와 대비되는 전형적인 방법은 일종의 거대 공학적 접근 방식이다. 코드는 모듈들로 분류되고, 각 모듈은 진공 상태에서 작성된다.)
    - 예광탄 코드 접근 방법에는 여러 장점이 있다.
        - 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.
        - 개발자들은 들어가서 일할 수 있는 구조를 얻는다.
        - 통합 작업을 수행할 기반이 생긴다.
        - 보여줄 것이 생긴다.
        - 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.

p.100

- 예광탄이 언제나 목표물을 맞추는 것은 아니다. 그럴 경우 목표물이 맞을 때까지 조준을 옮겨야 한다. 이것이 핵심이다.  지금 있는 것을 목표물에 가까이 가져가려면 어떻게 바꾸어야 할지 생각해내고, 가벼운 개발 방법론을 선택했다는 사실에 감사하라.

p.101

- 예광탄 코드 대 프로토타이핑
    - 예광탄 코드가 프로토타이핑과 다른 점은 프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 진짜 프로토타입 방식을 따른다면, 어떤 개념을 구현해 보려고 시도할 때 대충끼워 맞춘 것들을 모두 버린 다음, 실험 과정에서 얻은 교휸을 바탕으로 다시 코드를 만들게 된다.
    - 프로토타입은 나중에 버릴 코드를 만든다.
    - 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다.

p.104

- 프로토타입과 포스트잇
    - 프로토타입을 통해서 위험 요소를 분석하고 노출시키며 이를 매우 저렴한 비용으로 바로잡을 기회를 얻는 것이다.
    - 포스트잇은 작업흐름과 애플리케이션 로직과 같은 동적인 것들을 프로토타이핑해 볼 수 있는 훌륭한 도구다. 인터페이스만을 그려보는 방법으로 프로토타입을 만들 수 있다.

p.105

- 프로토타입의 대상 : 위험을 수반하는 모든 것이다. 또한 이전에 해본 적이 없는 것, 최종 시스템에 매우 중요한 것 등이 프로토타입의 대상이 된다.
    - 프로토타이핑은 학습 경험이며, 프로토타입의 가치는 생성된 코드에 있는 것이 아니라 이를 통해 배우게 되는 교훈에 있다.

p.106

- 프로토타입을 만들 때 무시해도 좋은 세부사항은 무엇인가?
    - 정확성 : 가짜 dummy 데이터를 사용할 수 있다.
    - 완전성 : 제한된 기능만을 제공한다.
    - 안정성 : 에러 검사는 불완전할 수도 있고, 때론 완전히 무시될 수 있다.
    - 스타일 : 프로토타입 자체에는 많은 문서를 많이 만들어 넣지 않아도 된다.
- 프로토타입은 세부사항을 생략하고 시스템의 특정 측면에 초점을 맞추기 때문에 프로젝트를 진행하는 언어보다 고수준 언어(펄, 파이썬, Tcl)를 이용하여 구현할 수 있다.

p.107

- 아키텍처 프로토타이핑
    - 아키텍처를 프로토타이핑할 때 코드를 작성하지 않고 화이트보드, 포스트잇, 인덱스카드 등을 사용해도 된다. 프로토타입에서 기대하는 것은 전체적으로 시스템이 어떻게 동작할지에 대한 감을 잡는 것이다. 다시 말하면 세부사항은 무시한다.

p.108

- 어떻게 프로토타입을 사용하지 않을 것인가?
    - 프로토타입을 코드로 만들 때는 시작하기 전에 항상 모든 사람에게 여러분이 폐기처분할 코드를 작성하고 있다는 사실을 이해시켜야 한다. 프로토타입을 적절히 사용하면 많은 시간과 돈, 고통과 고생을 줄일 수 있다.

p.110

- 도메인 언어
    - 최종 사용자의 도메인에 더 가깝게 일할 수 있는 도구를 여러분 스스로에게 제공하라는 뜻이다.
    - 문제 도메인에 가깝게 프로그래밍하라.
    - 각자의 문제 도메인이 있기 때문에, 각각에게 소형 환경과 소형 언어를 만들어 줄 수도 있다.
- 소형 언어를 구현하기
    - 가장 간단하게 소형 언어를 구현하는 방법은, 파싱하기 쉬운 라인중심 형식의 언어로 만드는 것이다.

p.114

- 데이터 언어와 명령형 언어
    - 여러분이 구현하는 언어는 서로 다른 두 가지 방법으로 쓰일 수 있다.
        - 데이터 언어는 애플리케이션이 사용할 어떤 형식의 데이터 구조를 만든다. 이런 언어는 환경설정 정보를 표현하기 위해 쓰이는 경우가 많다.
        - 명령형 언어는 실제로 실행되며 문장, 제어 구조체 등등을 가질 수 있다.
            - 프로그램의 유지보수를 쉽게 하기 위해서도 스스로 명령형 언어를 만들어 사용할 수 있다.

p.117

- 독립 언어와 내장 언어
    - 반드시 애플리케이션에 직접 사용되어야만 소형 언어가 유용한 것은 아니다. 많은 경우 우리는 컴파일하거나, 읽어들이거나, 그렇지 않을 경우 프로그램 자체가 사용하기 위한 산출물을 만들기 위해 명세 언어를 사용하기도 한다.
    - 애플리케이션 도메인이 동적이라면 컴파일을 다시 할 필요없이 읽어 들이는 스크립트만 바꿔서 애플리케이션의 동작을 변경하는 일이 가능해져 유지보수를 상당히 간단하게 만들 수 있다.
- 쉬운 개발 아니면 쉬운 유지보수?
    - 복잡한 문법에 대한 트레이드오프 대상은 확장가능성과 유지보수다. 진짜 언어를 파싱하는 코드는 작성하기는 힘들지만 사람들이 그 언어를 이해하기는 훨씬 쉬우며 나중에 새로운 특징이나 기능을 추가해 확장하기도 훨씬 쉽다.

p.120

- 추정 : 추정을 통하여 놀람을 피하라.
    - 얼마나 정확한 것이 충분히 정확한 것인가?
        - 누군가 추정치를 물었을 때, 자신에게 물어보아야 할 첫 번째 질문은 여러분의 답변이 사용될 상황이다. 질문자가 매우 높은 정확도의 답을 요구하는가, 아니면 단순히 큰 그림만을 요구하는가?
        - 추정에서 한 가지 재미있는 사실은 사용하는 단위가 결과의 해석에 차이를 가져온다는 것이다.
    - 추정치는 어디에서 오는가?
        - 항상 좋은 답을 알려준느 기본적인 추정 기술은 이미 그 일을 해본 사람에게 물어보라는 것이다. 모델 작성에 몰입하기 전에 과거에 비슷한 상황에 처했던 사람이 없는지 주변 사람들에게 문의해보고, 그들이 어떻게 문젤르 해결했는지 이해하려 노력해보자. 다른 사람들의 경험을 통해 성공적인 추정치를 낼 수 있다.
    - 무엇을 묻고 있는지 이해하자.
        - 정확도만이 아니라 도메인의 범위에 대해 감을 잡을 필요가 있다.
    - 시스템의 모델을 만들어보라.
        - 클라이언트가 요청한 것이 무엇인지 이해한 후에는 대략적이고 꾸밈없는 모델을 만들어 보라.
    - 모델을 컴포넌트로 나누어라. 컴포넌트 별 각 매개 변수를 규명하면 된다.
    - 각 매개 변수에 값을 주어라.결과에 큰 영향을 미치는 매개 변수가 무엇인지를 규명하고, 이 매개 변수의 값들을 최대한 정확히 산출해내는 것이다. 보통 결과에 단순히 더해지는 값보다는 곱하거나 나누는 값들이 결과에 큰 영향을 미친다.
    - 답을 계산하라. 중요 매개 변수들의 값을 변경시켜 가면서 여러 번 계산을 해보고, 이 가운데 어떤 것이 모델과 잘 들어맞는지 찾아내라.
    - 추정치를 기록하는 용기
        - 여러분이 계산한 추정치를 기록해 놓고, 이 값이 실제 결과에 얼마나 가까운지를 평가해 보는 것은 좋은 생각이다. 추정치가 잘못되더라도 움츠리거나 도망가지 마라. 왜 여러분의 추측과 실제 값이 달라졌는지 원인을 찾아야 한다.
    - 프로젝트 일정 추정하기
        - 코드와 함께 일정도 반복하며 조정하라.

### 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.

- 실용적인 프로그래밍을 하는 방법이 간단하지만은 않고 심오한 사상을 바탕으로 이루어진다.

#코딩 #개발자 #노마드북클럽 #노개북